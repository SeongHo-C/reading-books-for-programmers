<!--
bold 처리
** **

js 코드 작성
```js

```

링크
[보여질 단어](URL 주소)

형광펜 처리
` `

글자색
<span style="color:red"> </span>
-->

## Chapter 14: 가상 메모리

<details>
<summary>Table of Contents</summary>

- 연속 메모리 할당[:link:](#연속-메모리-할당)
  - 스와핑[:link:](#스와핑)
  - 메모리 할당[:link:](#메모리-할당)
  - 외부 단편화[:link:](#외부-단편화)
  </details>

### 연속 메모리 할당

프로세스에 연속적인 메모리 공간을 할당하는 방식을 `연속 메모리 할당` 방식이라고 한다.

#### 스와핑

입출력 작업의 요구로 대기 상태가 된, 오랫동안 사용되지 않은 프로세스들을 임시로 보조기억장치 일부 영역으로 쫓아내고, 그렇게 해서 생긴 메모리상의 빈 공간에 또 다른 프로세스를 적재하여 실행하는 방식을 `스와핑`이라고 한다.

- 프로세스들이 쫓겨나는 보조기억장치의 일부 영역을 `스왑 영역`
- 현재 실행되지 않는 프로세스가 메모리에서 스왑 영역으로 옮겨지는 것을 `스왑 아웃`
- 스왑 영역에 있던 프로세스가 다시 메모리로 옮겨오는 것을 `스왑 인`

스와핑을 이용하면 프로세스들이 요구하는 메모리 주소 공간의 크기가 실제 메모리 크기보다 큰 경우에도 프로세스들을 동시 실행할 수 있다.

#### 메모리 할당

비어 있는 메모리 공간에 프로세스를 연속적으로 할당하는 방식에는 대표적으로 `최초 적합`, `최적 적합`, `최악 적합`의 세 가지 방식이 있다.

`최초 적합`

- 운영체제가 메모리 내의 빈 공간을 순서대로 검색하다가 적재할 수 있는 공간을 발견하면 그 공간에 프로세스를 배치하는 방식이다.
- 최초 적합 방식은 프로세스가 적재될 수 있는 공간을 발견하는 즉시 메모리를 할당하는 방식이므로 검색을 최소화할 수 있고 결과적으로 빠른 할당이 가능하다.

`최적 적합`

- 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 작은 공간에 프로세스를 배치하는 방식이다.

`최악 적합`

- 운영체제가 빈 공간을 모두 검색해 본 후, 프로세스가 적재될 수 있는 공간 중 가장 큰 공간에 프로세스를 배치하는 방식이다.

#### 외부 단편화

메모리 할당

<img width="500" alt="image" src="https://github.com/SeongHo-C/reading-books-for-programmers/assets/83394485/b3a87056-01ab-4df4-9b5e-0347b54d977c">

메모리 해제

<img width="500" alt="image" src="https://github.com/SeongHo-C/reading-books-for-programmers/assets/83394485/84f6beb8-736f-4f57-93ad-69992e2b99d0">

프로세스를 메모리에 연속적으로 배치하는 연속 메모리 할당은 메모리를 효율적으로 사용하는 방법이 아니다. 왜냐하면 연속 메모리 할당은 `외부 단편화`라는 문제를 내포하고 있기 때문이다.

프로세스들이 메모리에 연속적으로 할당되는 환경에서는 위와 같이 프로세스들이 실행되고 종료되기를 반복하며 메모리 사이 사이에 빈 공간들이 생긴다. 프로세스 바깥에 생기는 이러한 빈 공간들은 분명 빈 공간이지만 그 공간보다 큰 프로세스를 적재하기 어려운 상황을 초래하고, 결국 메모리 낭비로 이어진다. 이러한 현상을 `외부 단편화`라고 한다.

외부 단편화를 해결할 수 있는 대표적인 방안으로 메모리를 `압축`하는 방법이 있다. 압축은 여기저기 흩어져 있는 빈 공간들을 하나로 모으는 방식으로 메모리 내에 저장된 프로세스를 적당히 재배치시켜 여기저기 흩어져 있는 작은 빈 공간들을 하나의 큰 빈 공간으로 만드는 방법이다.

압축 방식의 단점 </br>
⓵ 작은 빈 공간들을 하나로 모으는 동안 시스템은 하던 일을 중지 </br>
⓶ 메모리에 있는 내용을 옮기는 작업은 많은 오버헤드를 야기 </br>
⓷ 어떤 프로세스를 어떻게 움직여야 오버헤드를 최소화하며 압축할 수 있는지에 대한 명확한 방법을 결정하기 어려움
