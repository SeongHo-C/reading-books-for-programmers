<!--
bold 처리
** **

js 코드 작성
```js

```

링크
[보여질 단어](URL 주소)

형광펜 처리
` `
-->

## Chapter 11: CPU 스케줄링

<details>
<summary>Table of Contents</summary>

- CPU 스케줄링 개요[:link:](#cpu-스케줄링-개요)
  - 프로세스 우선순위[:link:](#프로세스-우선순위)
  - 스케줄링 큐[:link:](#스케줄링-큐)
  - 선점형과 비선점형 스케줄링[:link:](#선점형과-비선점형-스케줄링)
  </details>

### CPU 스케줄링 개요

운영체제가 프로세스들에게 공정하고 합리적으로 CPU 자원을 배분하는 것을 `CPU 스케줄링`이라고 한다.

#### 프로세스 우선순위

- 프로세스마다 `우선순위`가 다르다. 우선순위가 높은 프로세스(입출력 작업이 많은 프로세스)란 빨리 처리해야 하는 프로세스들을 의미한다.
- 대부분의 프로세스들은 CPU와 입출력장치를 모두 사용하며 실행된다. 달리 말하면 프로세스는 실행 상태와 대기 상태를 반복하며 실행된다.
- 비디오 재생이나 디스크 백업 작업을 담당하는 프로세스와 같이 입출력 작업이 많은 프로세스를 `입출력 집중 프로세스`라고 하고, 복잡한 수학 연산, 컴파일, 그래픽 처리 작업을 담당하는 프로세스와 같이 CPU 작업이 많은 프로세스를 `CPU 집중 프로세스`라고 한다.
  - CPU를 이용하는 작업을 `CPU 버스트`라 하고, 입출력장치를 기다리는 작업을 `입출력 버스트`라 부른다.
- 입출력 집중 프로세스를 가능한 한 빨리 실행시켜 입출력장치를 끊임없이 작동시키고, 그 다음 CPU 집중 프로세스에 집중적으로 CPU를 할당하는 것이 더 효율적이다. 입출력장치가 입출력 작업을 완료하기 전까지는 입출력 집중 프로세스는 어차피 대기 상태가 될 예정이기 때문에 입출력 집중 프로세스를 얼른 먼저 처리해 버리면 다른 프로세스가 CPU를 사용할 수 있기 때문이다.
- 운영체제는 각 프로세스의 PCB에 `우선순위`를 명시하고, PCB에 적힌 우선순위를 기준으로 먼저 처리할 프로세스를 결정한다.

#### 스케줄링 큐

- PCB에 우선순위가 적혀 있다고는 하지만, CPU를 사용할 다음 프로세스를 찾기 위해 운영체제가 일일이 모든 프로세스의 PCB를 뒤적거리는 것은 비효율적이다.
- CPU를 사용하고 싶은 프로세스들, 메모리에 적재되고 싶은 프로세스들, 특정 입출력장치를 사용하고 싶은 프로세스들을 모두 줄 세운다. 그리고 운영체제는 이 줄을 `스케줄링 큐`로 구현하고 관리한다.
- `준비 큐`는 CPU를 이용하고 싶은 프로세스들이 서는 줄을 의미하고, `대기 큐`는 입출력장치를 이용하기 위해 대기 상태에 접어든 프로세스들이 서는 줄을 의미한다.
- 운영체제는 PCB들이 큐에 삽입된 순서대로 프로세스를 하나씩 꺼내어 실행하되, 그중 우선순위가 높은 프로세스를 먼저 실행한다.
- 입출력이 완료되어 **완료 인터럽트가 발생**하면 운영체제는 대기 큐에서 작업이 완료된 PCB를 찾고, 이 PCB를 준비 상태로 변경한 뒤 대기 큐에서 제거한다. 당연히 해당 PCB는 준비 큐로 이동한다.

#### 선점형과 비선점형 스케줄링

- `선점형 스케줄링`은 프로세스가 CPU를 비롯한 자원을 사용하고 있더라도 운영체제가 프로세스로부터 자원을 강제로 빼앗아 다른 프로세스에 할당할 수 있는 스케줄링 방식을 의미한다.
  - 더 급한 프로세스가 언제든 끼어들어 사용할 수 있는 스케줄링 방식이므로 어느 한 프로세스의 자원 독점을 막고 프로세스들에 골고루 자원을 배분할 수 있다는 장점이 있지만, 그만큼 문맥 교환과정에서 오버헤드가 발생할 수 있다.
- `비선점형 스케줄링`이란 하나의 프로세스가 자원을 사용하고 있다면 그 프로세스가 종료되거나 스스로 대기 상태에 접어들기 전까진 다른 프로세스가 끼어들 수 없는 스케줄링 방식의 의미한다.
  - 문맥 교환의 횟수가 선점형 스케줄링보다 적기 때문에 문맥 교환에서 발생하는 오버헤드는 선점형 스케줄링보다 적지만, 하나의 프로세스가 자원을 사용 중이라면 당장 자원을 사용해야 하는 상황에서도 무작정 기다리는 수밖에 없다.
  - 모든 프로세스가 골고루 자원을 사용할 수 없다는 단점이 있다.
